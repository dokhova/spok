<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title data-translate="page_title">Potok — Profile</title>
  
  <!-- Telegram WebApp SDK -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-4834XVE45Z"></script>
  <script>
    // URLs для разных сервисов
    const GOOGLE_SHEETS_API = 'https://script.google.com/macros/s/AKfycbwm7GCmnIEgB-9KhcDZ4IYzxwhi36Kt16tnRrtBXJZBW6UrttjMQjRydqKR3uVjM2rf/exec'; // Уведомления
    const PAYMENTS_API = 'https://script.google.com/macros/s/AKfycbxXUSR-OlRVHGd4n9wNCd-xnUNlo6_NthH78zKcdX1LCGJtSeX06QswXl0dMGkBHa8vZw/exec'; // Платежи

    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-4834XVE45Z', {
      enhanced_measurement: true
    });

    // Функции для отслеживания событий профиля
    function trackNotificationToggle(type, enabled) {
      console.log('Переключение уведомления:', type, enabled ? 'включено' : 'выключено');
      gtag('event', 'notification_toggle', {
        event_category: 'profile',
        event_label: type,
        value: enabled ? 1 : 0
      });
    }

    function trackSupportClick() {
      console.log('Клик по поддержке');
      gtag('event', 'support_click', {
        event_category: 'profile',
        event_label: 'telegram_support',
        value: 1
      });
    }

    // НОВОЕ: Отслеживание доната
    function trackDonationClick(amount) {
      console.log('Клик по донату:', amount, 'Stars');
      gtag('event', 'donation_click', {
        event_category: 'monetization',
        event_label: 'stars_donation',
        value: amount
      });
    }

    function trackDonationSuccess(amount) {
      console.log('Успешный донат:', amount, 'Stars');
      gtag('event', 'donation_success', {
        event_category: 'monetization',
        event_label: 'stars_donation_completed',
        value: amount
      });
    }

    function trackInstallPrompt() {
      console.log('Клик по установке PWA');
      gtag('event', 'pwa_install_prompt', {
        event_category: 'profile',
        event_label: 'add_to_homescreen',
        value: 1
      });
    }

    function trackNavigation(navItem) {
      console.log('Клик по табу:', navItem);
      gtag('event', 'navigation', {
        event_category: 'tab_bar',
        event_label: navItem,
        value: 1
      });
    }

    // Инициализация отслеживания
    document.addEventListener('DOMContentLoaded', function() {
      console.log('Google Analytics загружается на странице Профиль...');
      
      if (typeof gtag !== 'undefined') {
        console.log('✅ Google Analytics работает на Профиле!');
        gtag('event', 'profile_page_loaded', {
          event_category: 'page',
          event_label: 'profile'
        });
      } else {
        console.log('❌ Google Analytics НЕ работает!');
      }

      // Отслеживание навигации
      setTimeout(() => {
        const tabs = document.querySelectorAll('.tab');
        tabs.forEach(function(tab) {
          tab.addEventListener('click', function() {
            const tabName = tab.querySelector('div')?.textContent || 'Unknown';
            trackNavigation(tabName);
          });
        });
      }, 1000);

      // Отслеживание времени на странице
      setTimeout(function() {
        gtag('event', 'profile_time_spent', {
          event_category: 'engagement',
          event_label: 'stayed_15_seconds',
          value: 15
        });
      }, 15000);
    });
  </script>

  <style>
    :root {
      --main: #19191B;
      --white: #ffffff;
      --text-2: #b3b3b3;
      --green: #34A853;
      --card-bg: rgba(255, 255, 255, 0.05);
      --border: rgba(255, 255, 255, 0.15);
      --donation-gradient: linear-gradient(135deg, #FFD527 8%, #34A853 85%, #4285F4 98%);
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background-color: var(--main);
      font-family: "Inter", sans-serif;
    }

    a {
      text-decoration: none;
      color: inherit;
    }

    /* Language Switcher */
    .language-switcher {
      position: fixed;
      top: 24px;
      right: calc(50vw - 163.5px);
      z-index: 200;
      display: flex;
      gap: 8px;
      background: rgba(255, 255, 255, 0.05);
      padding: 4px;
      border-radius: 8px;
      backdrop-filter: blur(10px);
    }

    @media (max-width: 425px) {
      .language-switcher {
        right: 24px;
      }
    }

    .lang-btn {
      background: none;
      border: none;
      color: var(--text-2);
      font-size: 12px;
      font-weight: 500;
      padding: 6px 12px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      font-family: "Inter", sans-serif;
    }

    .lang-btn.active {
      background: linear-gradient(135deg, #FFD527 8%, #34A853 85%, #4285F4 98%);
      color: white;
    }

    .lang-btn:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .lang-btn.active:hover {
      background: linear-gradient(135deg, #FFD527 8%, #34A853 85%, #4285F4 98%);
    }

    /* Header with back button */
    .header {
      position: fixed;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      max-width: 375px;
      width: 100%;
      z-index: 100;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: var(--main);
      padding: 24px 24px 24px 24px;
      box-sizing: border-box;
    }

    .back-button {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 32px;
      background-color: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      border: none;
      transition: background-color 0.2s;
      cursor: pointer;
    }

    .back-button:active {
      background-color: rgba(255, 255, 255, 0.2);
    }

    .back-arrow {
      width: 16px;
      height: 16px;
      color: var(--white);
    }

    /* Main container */
    .container {
      max-width: 375px;
      margin: 0 auto;
      padding: 105px 24px 24px 24px;
      display: flex;
      flex-direction: column;
      padding-bottom: 72px;
      box-sizing: border-box;
    }

    /* User Profile Section */
    .user-profile {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 48px;
    }

    .user-avatar {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: linear-gradient(135deg, #FFD527 8%, #34A853 85%, #4285F4 98%);
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 16px;
      overflow: hidden;
    }

    .user-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 50%;
    }

    .user-avatar-fallback {
      font-size: 32px;
      font-weight: 600;
      color: white;
    }

    .user-name {
      font-size: 20px;
      font-weight: 600;
      color: var(--white);
      margin: 0;
      text-align: center;
    }

    /* Navigation Items */
    .nav-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 16px;
      background-color: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      height: 80px;
      margin-bottom: 12px;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .nav-item:hover {
      background-color: rgba(255, 255, 255, 0.08);
    }

    .nav-item:active {
      background-color: rgba(255, 255, 255, 0.1);
    }

    .nav-item-content {
      display: flex;
      flex-direction: column;
      gap: 0px;
    }

    .nav-item-title {
      font-size: 16px;
      font-weight: 600;
      line-height: 24px;
      color: var(--white);
      margin: 0;
    }

    .nav-item-subtitle {
      font-size: 12px;
      color: var(--text-2);
      line-height: 16px;
      margin: 0;
    }

    .nav-arrow {
      width: 12px;
      height: 12px;
      color: var(--text-2);
      transition: transform 0.2s;
    }

    .nav-item:hover .nav-arrow {
      transform: translateX(2px);
    }

    /* НОВОЕ: Donation Section */
    .donation-section {
      background: transparent;
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 24px;
      text-align: center;
      color: var(--white);
      position: relative;
    }

    .donation-header {
      margin-bottom: 20px;
    }

    .donation-title {
      font-size: 20px;
      font-weight: 700;
      margin: 0 0 8px 0;
      letter-spacing: -0.02em;
      color: var(--white);
    }

    .donation-subtitle {
      font-size: 14px;
      font-weight: 400;
      margin: 0;
      color: var(--text-2);
      line-height: 1.4;
    }

    .donation-button {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: var(--white);
      padding: 14px 32px;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      min-width: 140px;
      justify-content: center;
    }

    .donation-button:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
    }

    .donation-button:active {
      transform: translateY(0);
      background: rgba(255, 255, 255, 0.2);
    }

    .donation-button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .star-icon {
      width: 20px;
      height: 20px;
      fill: currentColor;
    }

    /* PWA Install Button */
    .pwa-install {
      background: linear-gradient(135deg, #FFD527 8%, #34A853 85%, #4285F4 98%);
      color: white;
      border: none;
      padding: 16px 20px;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      width: 100%;
      margin-bottom: 12px;
      display: none;
    }

    .pwa-install:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(52, 168, 83, 0.3);
    }

    .pwa-install:active {
      transform: translateY(0);
    }

    .pwa-install.show {
      display: block;
    }

    /* Tab bar */
    .tab-bar {
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      max-width: 375px;
      background-color: var(--main);
      border-top: 1px solid rgba(255, 255, 255, 0.15);
      display: flex;
      justify-content: space-around;
      padding: 12px 0;
      z-index: 1000;
      
      padding-bottom: calc(12px + env(safe-area-inset-bottom));
      padding-bottom: calc(12px + 20px);
      padding-bottom: calc(12px + env(safe-area-inset-bottom, 20px));
    }

    .tab {
      display: flex;
      flex-direction: column;
      align-items: center;
      font-size: 12px;
      line-height: 18px;
      font-weight: 400;
      color: var(--text-2);
      gap: 8px;
    }

    .tab.active {
      font-weight: 600;
      color: var(--green);
    }

    .tab.active img {
      filter: brightness(1.5);
    }

    .tab img {
      width: 24px;
      height: 24px;
      transition: transform 0.1s, filter 0.1s;
    }

    .tab img:active {
      transform: scale(0.9);
      filter: brightness(1.5);
    }

    /* Loading state */
    .loading {
      text-align: center;
      color: var(--text-2);
      font-size: 14px;
      margin: 24px 0;
      display: none;
    }

    /* Modal for notifications */
    .notifications-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(0, 0, 0, 0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      backdrop-filter: blur(8px);
    }

    .notifications-modal.active {
      display: flex;
    }

    .notifications-content {
      background-color: var(--main);
      border-radius: 16px;
      padding: 24px 20px 20px 20px;
      max-width: 320px;
      width: 85%;
      border: 1px solid var(--border);
      position: relative;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
    }

    .notifications-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .notifications-title {
      font-size: 16px;
      font-weight: 600;
      color: var(--white);
      margin: 0;
    }

    .close-button {
      background: none;
      border: none;
      color: var(--text-2);
      cursor: pointer;
      padding: 8px;
      margin: -8px -8px -8px 8px;
      border-radius: 8px;
      transition: all 0.2s;
      font-size: 18px;
      line-height: 1;
      min-width: 32px;
      min-height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .close-button:hover {
      background-color: rgba(255, 255, 255, 0.1);
      color: var(--white);
    }

    .notification-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid var(--border);
    }

    .notification-item:last-child {
      border-bottom: none;
    }

    .notification-label {
      font-size: 14px;
      color: var(--white);
      font-weight: 500;
    }

    /* Toggle Switch */
    .toggle-switch {
      position: relative;
      width: 44px;
      height: 24px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    .toggle-switch.active {
      background: var(--green);
    }

    .toggle-switch::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 20px;
      height: 20px;
      background: var(--white);
      border-radius: 50%;
      transition: transform 0.3s;
    }

    .toggle-switch.active::after {
      transform: translateX(20px);
    }

    /* Bottom spacer */
    .bottom-spacer {
      height: 32px;
    }

    /* Status messages */
    .status-message {
      position: fixed;
      top: 24px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--green);
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      z-index: 1001;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .status-message.show {
      opacity: 1;
    }

    .status-message.error {
      background: #EA4335;
    }
  </style>
</head>
<body>
  <!-- Language Switcher -->
  <div class="language-switcher">
    <button class="lang-btn active" id="enBtn">EN</button>
    <button class="lang-btn" id="ruBtn">RU</button>
  </div>

  <!-- Header with back button -->
  <div class="header">
    <button class="back-button" onclick="window.location.href='index.html'">
      <svg class="back-arrow" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M10 12L6 8L10 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </button>
    <div></div>
  </div>

  <!-- Status message -->
  <div class="status-message" id="statusMessage"></div>

  <div class="container">
    <!-- User Profile Section -->
    <div class="user-profile">
      <div class="user-avatar" id="userAvatar">
        <div class="user-avatar-fallback" id="userAvatarFallback">U</div>
      </div>
      <h1 class="user-name" id="userName" data-translate="guest_user">Guest User</h1>
    </div>

    <!-- Support Section -->
    <div class="nav-item" onclick="openSupport()">
      <div class="nav-item-content">
        <h3 class="nav-item-title" data-translate="support">Поддержка</h3>
        <p class="nav-item-subtitle" data-translate="contact_support">Связаться с поддержкой</p>
      </div>
      <svg class="nav-arrow" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M6 4L10 8L6 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </div>

    <!-- Notifications Section -->
    <div class="nav-item" onclick="openNotificationsModal()">
      <div class="nav-item-content">
        <h3 class="nav-item-title" data-translate="notifications">Оповещения</h3>
        <p class="nav-item-subtitle" data-translate="notification_settings">Настроить напоминания</p>
      </div>
      <svg class="nav-arrow" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M6 4L10 8L6 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </div>

    <!-- PWA Install Button -->
    <button class="pwa-install" id="pwaInstall" data-translate="add_to_homescreen">Добавить на главный экран</button>

    <!-- Terms of Use Section -->
    <div class="nav-item" onclick="window.location.href='privacy.html'">
      <div class="nav-item-content">
        <h3 class="nav-item-title" data-translate="terms_of_use">Условия использования</h3>
        <p class="nav-item-subtitle" data-translate="read_terms">Прочитать правила</p>
      </div>
      <svg class="nav-arrow" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M6 4L10 8L6 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </div>

    <!-- НОВОЕ: Donation Section -->
    <div class="donation-section">
      <div class="donation-header">
        <h3 class="donation-title" data-translate="donation_title">Keep the flame alive</h3>
        <p class="donation-subtitle" data-translate="donation_subtitle">Sometimes we need a little fuel to keep moving</p>
      </div>
      <button class="donation-button" id="donationButton" onclick="openDonationOptions()">
        <svg class="star-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M12 2L14.09 8.26L22 8.27L15.95 12.74L18.18 19.02L12 14.77L5.82 19.02L8.05 12.74L2 8.27L9.91 8.26L12 2Z" fill="currentColor"/>
        </svg>
        <span data-translate="donation_button">Support</span>
      </button>
    </div>

    <div class="bottom-spacer"></div>
  </div>

  <!-- Notifications Modal -->
  <div class="notifications-modal" id="notificationsModal">
    <div class="notifications-content">
      <div class="notifications-header">
        <h3 class="notifications-title" data-translate="notifications">Оповещения</h3>
        <button class="close-button" id="closeNotifications">✕</button>
      </div>
      
      <div class="notification-item">
        <div class="notification-label" data-translate="emotion_calendar">Календарь эмоций</div>
        <div class="toggle-switch" id="emotionToggle"></div>
      </div>
    </div>
  </div>

  <!-- Tab bar -->
  <footer class="tab-bar">
    <a href="index.html" class="tab">
      <img src="img/home.svg" alt="Today">
      <div data-translate="tab_today">Today</div>
    </a>
    <a href="practices.html" class="tab">
      <img src="img/practices.svg" alt="Practices">
      <div data-translate="tab_practices">Practices</div>
    </a>
    <a href="journal.html" class="tab active">
      <img src="img/journal-active.svg" alt="Profile">
      <div data-translate="tab_profile">Profile</div>
    </a>
  </footer>

  <script>
    // ИСПРАВЛЕНО: GoogleSheetsService с решением CORS проблем (БЕЗ Firebase)
    class GoogleSheetsService {
      constructor() {
        this.isOnline = navigator.onLine;
        this.userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
        this.retryCount = 3;
        this.retryDelay = 1000;
        console.log('🌍 Пользователь находится в часовом поясе:', this.userTimezone);
        
        // Monitor online status
        window.addEventListener('online', () => {
          this.isOnline = true;
          console.log('🌐 Соединение восстановлено');
        });
        
        window.addEventListener('offline', () => {
          this.isOnline = false;
          console.log('🔴 Соединение потеряно');
        });
      }

      // ИСПРАВЛЕНО: Используем GET запросы вместо POST для CORS
      async makeRequest(action, params = {}) {
        console.log('📤 Начинаем GET запрос:', action, params);
        
        for (let attempt = 1; attempt <= this.retryCount; attempt++) {
          try {
            console.log(`🔄 Попытка ${attempt}/${this.retryCount} для действия: ${action}`);
            
            // ИСПРАВЛЕНО: Формируем GET URL с параметрами
            const url = new URL(GOOGLE_SHEETS_API);
            url.searchParams.append('action', action);
            
            Object.keys(params).forEach(key => {
              if (params[key] !== null && params[key] !== undefined) {
                url.searchParams.append(key, params[key].toString());
              }
            });

            console.log('📤 Отправляем GET запрос к:', url.toString());
            
            // ИСПРАВЛЕНО: Используем GET вместо POST
            const response = await fetch(url.toString(), {
              method: 'GET',
              mode: 'cors',
              cache: 'no-cache'
            });

            console.log('📡 Статус ответа:', response.status, response.statusText);

            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            // Получаем текст ответа для диагностики
            const responseText = await response.text();
            console.log('📄 Текст ответа:', responseText);

            // Пытаемся парсить JSON
            let data;
            try {
              data = JSON.parse(responseText);
            } catch (parseError) {
              console.error('❌ Ошибка парсинга JSON:', parseError);
              console.log('📄 Содержимое ответа:', responseText);
              
              // ИСПРАВЛЕНО: Если ответ не JSON, но содержит SUCCESS
              if (responseText.includes('SUCCESS') || responseText.includes('success')) {
                data = { success: true, message: 'Operation completed successfully' };
              } else {
                throw new Error('Сервер вернул некорректный JSON');
              }
            }

            console.log('📥 Обработанный ответ:', data);
            return data;
            
          } catch (error) {
            console.error(`❌ Ошибка на попытке ${attempt}:`, error);
            
            if (attempt === this.retryCount) {
              throw new Error(`Не удалось выполнить запрос после ${this.retryCount} попыток: ${error.message}`);
            }
            
            console.log(`⏳ Ожидание ${this.retryDelay}мс перед следующей попыткой...`);
            await new Promise(resolve => setTimeout(resolve, this.retryDelay));
            this.retryDelay *= 2;
          }
        }
      }

      // ИСПРАВЛЕНО: Улучшенный метод сохранения настроек уведомлений
      async saveNotificationSettings(userId, notificationEnabled, chatId = null) {
        console.log('🔔 ОТЛАДКА: Начинаем сохранение настроек уведомлений');
        console.log('📋 Параметры:', {
          userId: userId,
          notificationEnabled: notificationEnabled,
          chatId: chatId,
          timezone: this.userTimezone
        });

        const params = {
          user_id: userId,
          notification_enabled: notificationEnabled.toString(),
          timezone: this.userTimezone
        };

        if (chatId) {
          params.chat_id = chatId.toString();
        }

        try {
          console.log('📤 Отправляем GET запрос к Google Sheets...');
          console.log('🔗 URL:', GOOGLE_SHEETS_API);
          console.log('📋 Параметры запроса:', params);

          const response = await this.makeRequest('save-notification-settings', params);
          
          console.log('📥 Ответ от Google Sheets:', response);
          
          if (response && (response.success || response.success === undefined)) {
            console.log('✅ Настройки сохранены успешно');
            return response;
          } else {
            console.error('❌ Ошибка сохранения настроек:', response);
            throw new Error(response?.error || 'Неизвестная ошибка сервера');
          }
          
        } catch (error) {
          console.error('❌ Сетевая ошибка при сохранении настроек:', error);
          throw error;
        }
      }

      async loadNotificationSettings(userId) {
        console.log('🔍 Загрузка настроек уведомлений для:', userId);
        
        try {
          const response = await this.makeRequest('get-notification-settings', { user_id: userId });
          console.log('📋 Ответ при загрузке настроек:', response);
          return response;
        } catch (error) {
          console.error('❌ Ошибка загрузки настроек:', error);
          throw error;
        }
      }

      async registerChatId(userId, chatId) {
        console.log('📝 Регистрация chat_id:', userId, '->', chatId);
        
        try {
          const response = await this.makeRequest('register-chat-id', { 
            user_id: userId, 
            chat_id: chatId.toString(),
            timezone: this.userTimezone
          });
          console.log('📋 Ответ при регистрации chat_id:', response);
          return response;
        } catch (error) {
          console.error('❌ Ошибка регистрации chat_id:', error);
          throw error;
        }
      }
    }

    // НОВОЕ: DonationService для работы со Stars
    class DonationService {
      constructor() {
        // Используем отдельный API для платежей
        this.paymentsApi = PAYMENTS_API;
      }

      // Создание invoice для Stars через Google Apps Script
      async createInvoice(amount, title, description) {
        console.log('💰 Создание invoice для', amount, 'Stars через Payments API');
        
        try {
          const url = new URL(this.paymentsApi);
          url.searchParams.append('action', 'create-invoice');
          url.searchParams.append('amount', amount.toString());
          url.searchParams.append('title', title);
          url.searchParams.append('description', description);
          url.searchParams.append('user_id', window.profileService?.userId || 'unknown');

          console.log('📤 Отправляем запрос к Payments API:', url.toString());

          const response = await fetch(url.toString(), {
            method: 'GET',
            mode: 'cors',
            cache: 'no-cache'
          });

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          const responseText = await response.text();
          console.log('📄 Ответ от Payments API:', responseText);
          
          let data;
          
          try {
            data = JSON.parse(responseText);
          } catch (parseError) {
            console.error('❌ Ошибка парсинга ответа:', parseError);
            console.log('📄 Содержимое ответа:', responseText);
            throw new Error('Сервер вернул некорректный JSON');
          }
          
          if (data.success) {
            console.log('✅ Invoice создан через Payments API:', data.invoice_url);
            return data.invoice_url;
          } else {
            throw new Error(data.error || 'Ошибка создания invoice');
          }
          
        } catch (error) {
          console.error('❌ Ошибка создания invoice:', error);
          throw error;
        }
      }

      // Открытие платежа через Telegram WebApp
      async openPayment(invoiceUrl) {
        console.log('🚀 Открытие платежа:', invoiceUrl);
        
        if (typeof window.Telegram !== 'undefined' && window.Telegram.WebApp) {
          try {
            window.Telegram.WebApp.openInvoice(invoiceUrl, (status) => {
              console.log('💳 Статус платежа:', status);
              
              if (status === 'paid') {
                console.log('✅ Платеж успешен!');
                trackDonationSuccess(amount);
                this.showSuccessMessage();
              } else if (status === 'cancelled') {
                console.log('❌ Платеж отменен');
                this.showCancelMessage();
              } else if (status === 'failed') {
                console.log('❌ Ошибка платежа');
                this.showErrorMessage();
              }
            });
          } catch (error) {
            console.error('❌ Ошибка открытия платежа:', error);
            throw error;
          }
        } else {
          // Fallback: открыть в новом окне
          console.log('📱 Telegram WebApp недоступен, открываем в новом окне');
          window.open(invoiceUrl, '_blank');
        }
      }

      showSuccessMessage() {
        window.profileService?.showStatusMessage('✅ Спасибо за поддержку!', 'success');
      }

      showCancelMessage() {
        window.profileService?.showStatusMessage('ℹ️ Платеж отменен', 'info');
      }

      showErrorMessage() {
        window.profileService?.showStatusMessage('❌ Ошибка платежа', 'error');
      }
    }

    // ИСПРАВЛЕНО: ProfileService БЕЗ Firebase
    class ProfileService {
      constructor() {
        this.isOnline = false;
        this.userId = null;
        this.isInitialized = false;
        this.serverSettingsLoaded = false;
        
        // ИСПРАВЛЕНО: Добавляем GoogleSheetsService
        this.sheetsService = new GoogleSheetsService();
        
        // НОВОЕ: Добавляем DonationService
        this.donationService = new DonationService();
        
        // User data
        this.userInfo = {
          userType: 'guest',
          telegramId: null,
          telegramData: null,
          verified: false,
          userName: '',
          avatarUrl: null
        };
        
        // ИСПРАВЛЕНО: Уведомления включены по умолчанию
        this.notificationSettings = {
          emotions: true
        };
        
        // Storage keys
        this.STORAGE_KEYS = {
          USER_ID: 'potok_stable_user_id',
          USER_INFO: 'potok_user_info',
          NOTIFICATIONS: 'potok_notification_settings'
        };
        
        // ИСПРАВЛЕНО: Инициализируем после готовности Telegram WebApp
        this.initializeWithDelay();
      }

      // ИСПРАВЛЕНО: Инициализация с задержкой для Telegram WebApp
      async initializeWithDelay() {
        // Ждем готовности DOM
        if (document.readyState !== 'complete') {
          await new Promise(resolve => {
            if (document.readyState === 'complete') {
              resolve();
            } else {
              window.addEventListener('load', resolve, { once: true });
            }
          });
        }

        // Инициализируем базовые данные
        this.initializeUserData();
        
        // ИСПРАВЛЕНО: Сначала загружаем локальные настройки
        this.loadNotificationSettings();
        this.isInitialized = true;

        // Если есть Telegram WebApp, ждем его готовности
        if (typeof window.Telegram !== 'undefined' && window.Telegram.WebApp) {
          console.log('🔄 Ожидание готовности Telegram WebApp...');
          
          // Повторно инициализируем данные через небольшую задержку
          setTimeout(() => {
            console.log('🔄 Повторная инициализация для Telegram пользователя');
            this.initializeUserData();
            this.updateUserUI();
          }, 1000);
        }

        // ИСПРАВЛЕНО: Загружаем настройки с сервера БЕЗ перезаписи пользовательских изменений
        this.loadNotificationSettingsFromServer();
      }

      initializeUserData() {
        console.log('🔍 Инициализация данных пользователя...');
        
        const telegramData = this.getTelegramUserData();
        
        if (telegramData) {
          this.userInfo.userType = 'telegram';
          this.userInfo.telegramId = telegramData.id;
          this.userInfo.telegramData = telegramData;
          this.userInfo.verified = true;
          
          // ИСПРАВЛЕНО: Улучшенная логика создания имени пользователя
          let userName = '';
          if (telegramData.first_name) {
            userName = telegramData.first_name;
            if (telegramData.last_name) {
              userName += ' ' + telegramData.last_name;
            }
          } else if (telegramData.username) {
            userName = '@' + telegramData.username;
          } else {
            userName = 'Telegram User';
          }
          
          this.userInfo.userName = userName;
          this.userInfo.avatarUrl = telegramData.photo_url;
          this.userId = `tg_${telegramData.id}`;
          
          console.log('🎯 Telegram пользователь:', this.userInfo.userName, 'ID:', this.userId);
          console.log('📱 Telegram данные:', telegramData);
          this.saveUserInfoToLocalStorage();
        } else {
          console.log('👤 Гостевой пользователь');
          this.loadUserInfoFromLocalStorage();
          
          if (!this.userId) {
            this.userId = this.generateGuestUserId();
          }
        }
        
        console.log('✅ Данные пользователя инициализированы:', {
          userId: this.userId,
          userType: this.userInfo.userType,
          userName: this.userInfo.userName,
          verified: this.userInfo.verified
        });
        
        // ИСПРАВЛЕНО: Обновляем UI после инициализации данных
        setTimeout(() => {
          this.updateUserUI();
        }, 100);
      }

      getTelegramUserData() {
        try {
          // ИСПРАВЛЕНО: Более детальные проверки
          console.log('🔍 Проверяем доступность Telegram WebApp...');
          console.log('window.Telegram:', typeof window.Telegram);
          
          if (typeof window.Telegram === 'undefined') {
            console.log('❌ window.Telegram не определен');
            return null;
          }
          
          console.log('window.Telegram.WebApp:', window.Telegram.WebApp);
          
          if (!window.Telegram.WebApp) {
            console.log('❌ window.Telegram.WebApp не доступен');
            return null;
          }
          
          console.log('window.Telegram.WebApp.initDataUnsafe:', window.Telegram.WebApp.initDataUnsafe);
          
          if (!window.Telegram.WebApp.initDataUnsafe) {
            console.log('❌ initDataUnsafe не доступен');
            return null;
          }
          
          console.log('user object:', window.Telegram.WebApp.initDataUnsafe.user);
          
          if (!window.Telegram.WebApp.initDataUnsafe.user?.id) {
            console.log('❌ user.id не найден');
            return null;
          }
          
          const user = window.Telegram.WebApp.initDataUnsafe.user;
          console.log('📱 Полные данные Telegram пользователя:', {
            id: user.id,
            first_name: user.first_name,
            last_name: user.last_name,
            username: user.username,
            language_code: user.language_code,
            photo_url: user.photo_url,
            is_premium: user.is_premium
          });
          
          return {
            id: user.id,
            first_name: user.first_name,
            last_name: user.last_name,
            username: user.username,
            language_code: user.language_code,
            photo_url: user.photo_url,
            is_premium: user.is_premium || false
          };
        } catch (error) {
          console.error('❌ Ошибка получения Telegram данных:', error);
          return null;
        }
      }

      // ИСПРАВЛЕНО: Метод для обновления UI пользователя
      updateUserUI() {
        const userNameElement = document.getElementById('userName');
        const userAvatarElement = document.getElementById('userAvatar');
        const userAvatarFallback = document.getElementById('userAvatarFallback');
        
        if (!userNameElement || !userAvatarElement || !userAvatarFallback) {
          console.log('⚠️ Элементы UI еще не готовы');
          return;
        }
        
        if (this.userInfo.userType === 'telegram') {
          // Telegram user
          let userName = this.userInfo.userName || 'Telegram User';
          
          // ИСПРАВЛЕНО: Если userName пустая строка, создаем из доступных данных
          if (!userName || userName.trim() === '') {
            const telegramData = this.userInfo.telegramData;
            if (telegramData) {
              if (telegramData.first_name) {
                userName = telegramData.first_name;
                if (telegramData.last_name) {
                  userName += ' ' + telegramData.last_name;
                }
              } else if (telegramData.username) {
                userName = '@' + telegramData.username;
              } else {
                userName = 'Telegram User';
              }
            } else {
              userName = 'Telegram User';
            }
          }
          
          console.log('👤 Устанавливаем имя пользователя:', userName);
          userNameElement.textContent = userName;
          
          // Обновляем аватар
          if (this.userInfo.avatarUrl) {
            // Очищаем предыдущие элементы
            userAvatarElement.innerHTML = '';
            
            const img = document.createElement('img');
            img.src = this.userInfo.avatarUrl;
            img.alt = userName;
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'cover';
            img.style.borderRadius = '50%';
            
            img.onerror = () => {
              console.log('❌ Ошибка загрузки аватара, используем fallback');
              userAvatarElement.innerHTML = '<div class="user-avatar-fallback">' + userName.charAt(0).toUpperCase() + '</div>';
            };
            
            img.onload = () => {
              console.log('✅ Аватар загружен успешно');
            };
            
            userAvatarElement.appendChild(img);
          } else {
            console.log('📷 Аватар недоступен, используем fallback');
            userAvatarElement.innerHTML = '<div class="user-avatar-fallback">' + userName.charAt(0).toUpperCase() + '</div>';
          }
        } else {
          // Guest user
          const guestText = window.translator ? window.translator.translate('guest_user') : 'Guest User';
          userNameElement.textContent = guestText;
          userAvatarElement.innerHTML = '<div class="user-avatar-fallback">G</div>';
        }
        
        console.log('✅ UI пользователя обновлен');
      }

      generateGuestUserId() {
        try {
          const savedId = localStorage.getItem(this.STORAGE_KEYS.USER_ID);
          if (savedId && !savedId.startsWith('tg_')) {
            console.log('💾 Найден сохраненный гостевой ID:', savedId);
            return savedId;
          }
        } catch (error) {
          console.log('⚠️ Ошибка чтения localStorage:', error);
        }

        const newId = `guest_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        try {
          localStorage.setItem(this.STORAGE_KEYS.USER_ID, newId);
          console.log('🆕 Создан новый гостевой ID:', newId);
        } catch (error) {
          console.log('⚠️ Не удалось сохранить ID в localStorage');
        }
        
        return newId;
      }

      saveUserInfoToLocalStorage() {
        try {
          const userInfoToSave = {
            ...this.userInfo,
            lastSeen: new Date().toISOString()
          };
          
          localStorage.setItem(this.STORAGE_KEYS.USER_INFO, JSON.stringify(userInfoToSave));
          localStorage.setItem(this.STORAGE_KEYS.USER_ID, this.userId);
          
          console.log('💾 Информация о пользователе сохранена в localStorage');
        } catch (error) {
          console.error('❌ Ошибка сохранения информации о пользователе:', error);
        }
      }

      loadUserInfoFromLocalStorage() {
        try {
          const savedUserInfo = localStorage.getItem(this.STORAGE_KEYS.USER_INFO);
          const savedUserId = localStorage.getItem(this.STORAGE_KEYS.USER_ID);
          
          if (savedUserInfo) {
            const parsedInfo = JSON.parse(savedUserInfo);
            this.userInfo = { ...this.userInfo, ...parsedInfo };
            console.log('💾 Информация о пользователе загружена из localStorage');
          }
          
          if (savedUserId) {
            this.userId = savedUserId;
            console.log('💾 User ID загружен из localStorage:', this.userId);
          }
        } catch (error) {
          console.error('❌ Ошибка загрузки информации о пользователе:', error);
        }
      }

      loadNotificationSettings() {
        try {
          const savedSettings = localStorage.getItem(this.STORAGE_KEYS.NOTIFICATIONS);
          if (savedSettings) {
            const parsedSettings = JSON.parse(savedSettings);
            // ИСПРАВЛЕНО: Проверяем, что это не первая загрузка
            if (parsedSettings.hasUserChanges !== undefined) {
              this.notificationSettings = { ...this.notificationSettings, ...parsedSettings };
              console.log('💾 Настройки уведомлений загружены из localStorage:', this.notificationSettings);
            } else {
              // ИСПРАВЛЕНО: Это старые настройки, используем defaults и отмечаем как пользовательские
              console.log('💾 Найдены старые настройки, применяем их как пользовательские');
              this.notificationSettings = { ...this.notificationSettings, ...parsedSettings, hasUserChanges: true };
              this.saveNotificationSettings();
            }
          } else {
            console.log('💾 Локальные настройки не найдены, используем defaults (включено)');
            // ИСПРАВЛЕНО: Сохраняем настройки по умолчанию только если их нет
            this.saveNotificationSettings();
          }
        } catch (error) {
          console.error('❌ Ошибка загрузки настроек уведомлений:', error);
        }
      }

      // ИСПРАВЛЕНО: Загрузка настроек с сервера только при первом запуске
      async loadNotificationSettingsFromServer() {
        if (!this.userId || !this.sheetsService) return;

        try {
          console.log('🔄 Загружаем настройки с сервера...');
          const response = await this.sheetsService.loadNotificationSettings(this.userId);
          
          if (response && response.notification_enabled !== undefined) {
            // Преобразуем строку в boolean
            const serverEnabled = response.notification_enabled === 'true' || response.notification_enabled === true;
            
            // ИСПРАВЛЕНО: Используем серверные настройки только если нет пользовательских изменений
            if (!this.notificationSettings.hasUserChanges) {
              console.log('📥 Используем настройки с сервера (нет пользовательских изменений)');
              this.notificationSettings.emotions = serverEnabled;
              this.saveNotificationSettings();
            } else {
              console.log('👤 Пользователь уже менял настройки, игнорируем серверные');
            }
            
            // Обновляем UI
            this.updateNotificationToggles();
            this.serverSettingsLoaded = true;
            
            console.log('✅ Загрузка с сервера завершена. Текущие настройки:', this.notificationSettings);
          }
          
          // ИСПРАВЛЕНО: Обновляем UI пользователя после загрузки с сервера
          setTimeout(() => {
            this.updateUserUI();
          }, 200);
          
        } catch (error) {
          console.error('❌ Ошибка загрузки настроек с сервера:', error);
          this.serverSettingsLoaded = true; // Отмечаем как загруженные даже при ошибке
        }
      }

      saveNotificationSettings() {
        try {
          // ИСПРАВЛЕНО: Добавляем флаг, что пользователь менял настройки
          const settingsToSave = {
            ...this.notificationSettings,
            hasUserChanges: true,
            lastModified: new Date().toISOString()
          };
          
          localStorage.setItem(this.STORAGE_KEYS.NOTIFICATIONS, JSON.stringify(settingsToSave));
          console.log('💾 Настройки уведомлений сохранены:', settingsToSave);
        } catch (error) {
          console.error('❌ Ошибка сохранения настроек уведомлений:', error);
        }
      }

      // ИСПРАВЛЕНО: Переключение уведомлений с улучшенной логикой
      async toggleNotification(type) {
        console.log('🔄 Переключение уведомления:', type);
        
        const oldValue = this.notificationSettings[type];
        const newValue = !oldValue;
        
        // ИСПРАВЛЕНО: Сразу обновляем UI для отзывчивости
        this.notificationSettings[type] = newValue;
        this.notificationSettings.hasUserChanges = true;
        this.updateNotificationToggles();
        
        // Отслеживаем событие
        trackNotificationToggle(type, newValue);
        
        console.log(`🔔 Уведомление ${type} ${newValue ? 'включено' : 'выключено'}`);
        
        // Сохраняем локально
        this.saveNotificationSettings();
        
        // Сохраняем на сервер
        try {
          console.log('📤 Сохраняем на сервер...');
          const chatId = this.userInfo.telegramData?.id || null;
          await this.sheetsService.saveNotificationSettings(this.userId, newValue, chatId);
          
          // Показываем успешное сообщение
          this.showStatusMessage('✅ Настройки сохранены', 'success');
          console.log('✅ Настройки успешно сохранены на сервер');
          
        } catch (error) {
          console.error('❌ Ошибка сохранения на сервер:', error);
          
          // ИСПРАВЛЕНО: НЕ откатываем изменения при ошибке сервера
          // Локальные настройки остаются, покажем предупреждение
          this.showStatusMessage('⚠️ Сохранено локально', 'warning');
          console.log('⚠️ Настройки сохранены локально, но не на сервере');
        }
      }

      updateNotificationToggles() {
        const emotionToggle = document.getElementById('emotionToggle');

        if (emotionToggle) {
          emotionToggle.classList.toggle('active', this.notificationSettings.emotions);
          console.log('🔄 UI обновлен. Emotion toggle:', this.notificationSettings.emotions);
        }
      }

      // ИСПРАВЛЕНО: Добавляем метод для показа статусных сообщений
      showStatusMessage(message, type = 'success') {
        const statusElement = document.getElementById('statusMessage');
        if (!statusElement) return;

        statusElement.textContent = message;
        
        // ИСПРАВЛЕНО: Поддержка warning типа
        let className = 'status-message show';
        if (type === 'error') {
          className += ' error';
        } else if (type === 'warning') {
          statusElement.style.background = '#FF9500'; // Orange for warning
        } else {
          statusElement.style.background = ''; // Reset to default (green)
        }
        
        statusElement.className = className;

        setTimeout(() => {
          statusElement.classList.remove('show');
        }, 3000);
      }
    }

    // PWA Installation
    class PWAInstaller {
      constructor() {
        this.deferredPrompt = null;
        this.setupInstallPrompt();
      }

      setupInstallPrompt() {
        window.addEventListener('beforeinstallprompt', (e) => {
          console.log('🎯 PWA установка доступна');
          e.preventDefault();
          this.deferredPrompt = e;
          this.showInstallButton();
        });

        window.addEventListener('appinstalled', () => {
          console.log('✅ PWA установлено');
          this.hideInstallButton();
        });
      }

      showInstallButton() {
        const installButton = document.getElementById('pwaInstall');
        if (installButton) {
          installButton.classList.add('show');
        }
      }

      hideInstallButton() {
        const installButton = document.getElementById('pwaInstall');
        if (installButton) {
          installButton.classList.remove('show');
        }
      }

      async install() {
        if (!this.deferredPrompt) {
          console.log('⚠️ PWA установка недоступна');
          return;
        }

        this.deferredPrompt.prompt();
        const { outcome } = await this.deferredPrompt.userChoice;
        
        if (outcome === 'accepted') {
          console.log('✅ Пользователь принял установку PWA');
        } else {
          console.log('❌ Пользователь отклонил установку PWA');
        }
        
        this.deferredPrompt = null;
        this.hideInstallButton();
      }
    }

    // Translations
    const translations = {
      en: {
        page_title: "Potok — Profile",
        guest_user: "Guest User",
        support: "Support",
        contact_support: "Contact support",
        notifications: "Notifications",
        notification_settings: "Configure reminders",
        terms_of_use: "Terms of Use",
        read_terms: "Read the rules",
        add_to_homescreen: "Add to Home Screen",
        emotion_calendar: "Emotion Calendar",
        tab_today: "Today",
        tab_practices: "Practices", 
        tab_profile: "Profile",
        // НОВОЕ: Переводы для доната
        donation_title: "Keep the flame alive",
        donation_subtitle: "Sometimes we need a little fuel to keep moving",
        donation_button: "Support"
      },
      ru: {
        page_title: "Potok — Профиль",
        guest_user: "Гостевой пользователь",
        support: "Поддержка",
        contact_support: "Связаться с поддержкой",
        notifications: "Оповещения",
        notification_settings: "Настроить напоминания",
        terms_of_use: "Условия использования",
        read_terms: "Прочитать правила",
        add_to_homescreen: "Добавить на главный экран",
        emotion_calendar: "Календарь эмоций",
        tab_today: "Сегодня",
        tab_practices: "Практики",
        tab_profile: "Профиль",
        // НОВОЕ: Переводы для доната
        donation_title: "Чтобы не заглохло",
        donation_subtitle: "Иногда нужно немного топлива чтобы продолжать движение",
        donation_button: "Поддержать"
      }
    };

    // Translator class
    class Translator {
      constructor() {
        console.log('🔄 Инициализация переводчика PROFILE.HTML...');
        
        this.localStorageAvailable = this.checkLocalStorageAvailability();
        this.currentLang = this.getLanguageFromURL() || 
                          (this.localStorageAvailable ? this.getLanguageFromStorage() : null) || 
                          'en';
        
        console.log(`🌐 Выбранный язык: ${this.currentLang}`);
        this.init();
      }

      checkLocalStorageAvailability() {
        try {
          const testKey = 'test_storage_' + Date.now();
          localStorage.setItem(testKey, 'test');
          localStorage.removeItem(testKey);
          return true;
        } catch (error) {
          return false;
        }
      }

      getLanguageFromURL() {
        const urlParams = new URLSearchParams(window.location.search);
        const langFromUrl = urlParams.get('lang');
        console.log(`🔗 Язык из URL: ${langFromUrl}`);
        return langFromUrl;
      }

      getLanguageFromStorage() {
        if (!this.localStorageAvailable) return null;
        
        try {
          const langFromStorage = localStorage.getItem('potok_language');
          console.log(`💾 Язык из localStorage: ${langFromStorage}`);
          return langFromStorage;
        } catch (error) {
          console.log(`❌ Ошибка чтения localStorage: ${error.message}`);
          return null;
        }
      }

      init() {
        this.updatePage();
        this.updateLanguageButtons();
        this.updatePageLinks();
        this.setupLanguageButtons();
        document.documentElement.lang = this.currentLang;
        
        console.log(`✅ Переводчик PROFILE.HTML инициализирован с языком: ${this.currentLang}`);
      }

      setupLanguageButtons() {
        document.getElementById('enBtn')?.addEventListener('click', () => {
          console.log('🔘 Клик по EN в PROFILE.HTML');
          this.setLanguage('en');
        });
        
        document.getElementById('ruBtn')?.addEventListener('click', () => {
          console.log('🔘 Клик по RU в PROFILE.HTML');
          this.setLanguage('ru');
        });
      }

      setLanguage(lang) {
        console.log(`🔄 Смена языка на: ${lang} в PROFILE.HTML`);
        
        this.currentLang = lang;
        
        if (this.localStorageAvailable) {
          try {
            localStorage.setItem('potok_language', lang);
            console.log(`✅ Язык ${lang} сохранен в localStorage`);
          } catch (error) {
            console.log(`❌ Не удалось сохранить в localStorage: ${error.message}`);
          }
        }
        
        try {
          const newUrl = `${window.location.pathname}?lang=${lang}`;
          window.history.replaceState({}, '', newUrl);
          console.log(`✅ URL обновлен: ${newUrl}`);
        } catch (error) {
          console.log(`❌ Не удалось обновить URL: ${error.message}`);
        }
        
        this.updatePage();
        this.updateLanguageButtons();
        this.updatePageLinks();
        
        document.documentElement.lang = lang;
        
        console.log(`🌐 Язык изменен на: ${lang} в PROFILE.HTML`);
      }

      updatePageLinks() {
        const links = document.querySelectorAll('a[href$=".html"], a[href*=".html"]');
        let updateCount = 0;
        
        links.forEach(link => {
          let href = link.getAttribute('href');
          
          if (href.startsWith('http') || href.startsWith('//')) return;
          
          if (href.includes('?lang=')) {
            href = href.split('?')[0];
          }
          
          if (href.includes('#')) {
            const parts = href.split('#');
            href = parts[0];
          }
          
          const separator = href.includes('?') ? '&' : '?';
          const newHref = `${href}${separator}lang=${this.currentLang}`;
          link.setAttribute('href', newHref);
          updateCount++;
        });
        
        console.log(`🔗 Обновлено ${updateCount} ссылок с lang=${this.currentLang}`);
      }

      translate(key) {
        return translations[this.currentLang]?.[key] || translations.en[key] || key;
      }

      updatePage() {
        document.querySelectorAll('[data-translate]').forEach(element => {
          const key = element.getAttribute('data-translate');
          const translation = this.translate(key);
          
          if (element.tagName === 'TITLE') {
            element.textContent = translation;
          } else {
            element.textContent = translation;
          }
        });
        
        console.log(`🔄 Обновлено ${document.querySelectorAll('[data-translate]').length} элементов перевода`);
      }

      updateLanguageButtons() {
        document.querySelectorAll('.lang-btn').forEach(btn => {
          btn.classList.remove('active');
          if (btn.textContent.toLowerCase() === this.currentLang) {
            btn.classList.add('active');
            btn.style.background = 'linear-gradient(135deg, #FFD527 8%, #34A853 85%, #4285F4 98%)';
          } else {
            btn.style.background = '';
          }
        });
      }
    }

    // НОВОЕ: Global functions для доната
    async function openDonationOptions() {
      console.log('💰 Открытие опций доната');
      
      // Отслеживаем клик
      trackDonationClick(50); // Пример суммы
      
      // Блокируем кнопку на время создания invoice
      const button = document.getElementById('donationButton');
      const originalText = button.innerHTML;
      
      button.disabled = true;
      button.innerHTML = '⏳ Загрузка...';
      
      try {
        // Создаем invoice для 50 Stars (можно сделать выбор суммы позже)
        const amount = 50;
        const title = window.translator ? window.translator.translate('donation_title') : 'Support Potok';
        const description = window.translator ? window.translator.translate('donation_subtitle') : 'Thank you for your support!';
        
        const invoiceUrl = await window.profileService.donationService.createInvoice(amount, title, description);
        
        // Открываем платеж
        await window.profileService.donationService.openPayment(invoiceUrl);
        
      } catch (error) {
        console.error('❌ Ошибка при создании доната:', error);
        window.profileService?.showStatusMessage('❌ Ошибка создания платежа', 'error');
      } finally {
        // Возвращаем кнопку в исходное состояние
        button.disabled = false;
        button.innerHTML = originalText;
      }
    }

    // Global functions
    function openSupport() {
      trackSupportClick();
      window.open('https://t.me/spoksupport_bot', '_blank');
    }

    function openNotificationsModal() {
      document.getElementById('notificationsModal').classList.add('active');
    }

    function closeNotificationsModal() {
      document.getElementById('notificationsModal').classList.remove('active');
    }

    // Initialize app
    document.addEventListener('DOMContentLoaded', () => {
      console.log('📱 DOM загружен для Profile.html');
      
      // Initialize Telegram WebApp if available
      if (typeof window.Telegram !== 'undefined' && window.Telegram.WebApp) {
        console.log('📱 Telegram WebApp доступен');
        window.Telegram.WebApp.ready();
        window.Telegram.WebApp.expand();
        
        // ИСПРАВЛЕНО: Ждем готовности Telegram WebApp
        setTimeout(() => {
          console.log('🔄 Повторная инициализация после готовности Telegram WebApp');
          if (window.profileService) {
            window.profileService.initializeUserData();
          }
        }, 500);
      }
      
      // Initialize translator
      window.translator = new Translator();
      
      // Initialize profile service
      window.profileService = new ProfileService();
      
      // Initialize PWA installer
      window.pwaInstaller = new PWAInstaller();
      
      // ИСПРАВЛЕНО: Вызываем updateUserUI через ProfileService
      setTimeout(() => {
        if (window.profileService) {
          window.profileService.updateUserUI();
        }
      }, 300);
      
      // Setup event listeners
      setupEventListeners();
      
      console.log('✅ Профиль приложения инициализирован БЕЗ Firebase');
    });

    function updateUserUI() {
      // ИСПРАВЛЕНО: Перенаправляем на метод ProfileService
      if (window.profileService) {
        window.profileService.updateUserUI();
      } else {
        console.log('⚠️ ProfileService еще не готов');
        // Fallback для базового отображения
        const userNameElement = document.getElementById('userName');
        const userAvatarFallback = document.getElementById('userAvatarFallback');
        
        if (userNameElement && window.translator) {
          userNameElement.textContent = window.translator.translate('guest_user');
        }
        
        if (userAvatarFallback) {
          userAvatarFallback.textContent = 'G';
        }
      }
    }

    function setupEventListeners() {
      // Notification modal
      document.getElementById('closeNotifications').addEventListener('click', closeNotificationsModal);
      
      document.getElementById('notificationsModal').addEventListener('click', (e) => {
        if (e.target === document.getElementById('notificationsModal')) {
          closeNotificationsModal();
        }
      });
      
      // ИСПРАВЛЕНО: Notification toggles - асинхронный обработчик
      document.getElementById('emotionToggle').addEventListener('click', async () => {
        await window.profileService.toggleNotification('emotions');
      });
      
      // PWA install
      document.getElementById('pwaInstall').addEventListener('click', () => {
        trackInstallPrompt();
        window.pwaInstaller.install();
      });
      
      // ИСПРАВЛЕНО: Обновляем UI после инициализации
      setTimeout(() => {
        if (window.profileService) {
          window.profileService.updateNotificationToggles();
        }
      }, 500);
    }
  </script>
</body>
</html>